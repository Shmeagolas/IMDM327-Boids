// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


struct Boid
{
    float2 pos;
    float2 vel;
};

RWStructuredBuffer<Boid> Boids;


float _DeltaTime;


float _NeighborRadius;
float _SeparationDistance;
float _SeparationWeight;
float _AlignmentWeight;
float _CohesionWeight;
float _MaxSpeed; 
float _MinSpeed;
float _WorldX;
float _WorldY;

uint _NumBoids;


[numthreads(256,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if(index >= _NumBoids) return;

    Boid b = Boids[index];
   

    float2 cohesion = 0;
    float2 alignment = 0;
    float2 separation = 0;
    int neighborCount = 0;

    for(uint i = 0; i < _NumBoids; i++)
    {
        if(i == index) continue;
        Boid bo = Boids[i];


        float2 offset = bo.pos - b.pos;

        if (offset.x >  _WorldX) offset.x -= 2.0 * _WorldX;
    if (offset.x < -_WorldX) offset.x += 2.0 * _WorldX;
    if (offset.y >  _WorldY) offset.y -= 2.0 * _WorldY;
    if (offset.y < -_WorldY) offset.y += 2.0 * _WorldY;

        float distance = length(offset);

        if(distance < _NeighborRadius && distance > 0)
        {
            cohesion += bo.pos + offset;
            alignment += bo.vel;
            if(distance < _SeparationDistance) separation -= offset / (distance * distance);
            neighborCount++; 
        }

    }


    if(neighborCount > 0)
    {
        cohesion = (cohesion / neighborCount - b.pos) * _CohesionWeight;
        alignment = (alignment / neighborCount - b.vel / length(b.vel)) * _AlignmentWeight;
        separation *= _SeparationWeight;
    }

    float2 acceleration = cohesion + alignment + separation;
    b.vel += acceleration * _DeltaTime;
    

    float speed = length(b.vel);
    if(speed > _MaxSpeed)
    {
        b.vel = normalize(b.vel) * _MaxSpeed;
    }
    else if (speed < _MinSpeed && speed > 0.00001)
    {
        b.vel = normalize(b.vel) * _MinSpeed;
    }

    b.pos += b.vel * _DeltaTime;

    b.pos.x = fmod(b.pos.x + _WorldX, 2.0 * _WorldX);
    if (b.pos.x < 0) b.pos.x += 2.0 * _WorldX;
    b.pos.x -= _WorldX;

    b.pos.y = fmod(b.pos.y + _WorldY, 2.0 * _WorldY);
    if (b.pos.y < 0) b.pos.y += 2.0 * _WorldY;
    b.pos.y -= _WorldY;

    Boids[index] = b;
}


